## 高阶组件封装
1. 技巧
   1. 使用v-bind='$attrs'
   2. 使用v-on='$listener'
## 计算属性
### 使用get set
1. 核心
   1. 如果你需要控制一个属性的设置和获取
      1. 控制获取
         1. 比如：show.sync
            1. 正常情况 show是个data属性 子组件update:show来修改值
            2. 这时候可以通过计算属性的set对这个过程进行劫持
               1. 改成 this.$emit('update:visible') ---使用.sync的情况下
               2. 也可以改成 this.$emit('input) ---使用v-model的情况下
               3. 还可以改成 this.$store.commit('xxx') ---使用vuex的情况下
## 动态组件
1. 作用：
   1. 把那种需要一大堆if else的复杂组件模板模块化
   2. 拆分成组件
      1. 不同条件下使用不同的组件
2. 语法
   1. <div :is="cname"></div>
      1. 如果cname是'xx'
      2. 那么这段代码等于  <xx></xx>
   2. 其中这个div怎么写无所谓 会被忽略
## 生命周期
1. hook
   1. 内部监听
      1. 好处
         1. 相关的代码聚集到一起
         2. 比如echarts的销毁
   2. 监听第三方组件的生命周期
      1. <custom-select @hook:updated="$_handleSelectUpdated" />
```js
mounted () {
    console.log('init')
    this.$on('hook:updated', () => {console.log('update)})
    this.$once('hook:beforeDestroy', () => {
      console.log('des')
    })
  },
```
## 内置小型vuex
### 定义
```js
export const store = Vue.observable({xx:1})
export const mutations = {
  setXX(xx) {
    store.xx = xx
  }
}
```
### 使用
```js
import { store, mutations } from '../store'
console.log(store.xx)
mutations.setXX('xx')
```
### 全局组件
1. 好处
   1. 使用js控制组件
      1. 而不是传统的
         1. impoort引用 然后注册为组件 然后在模板中使用
2. demo 参考@/base/loading
3. 使用
   1. import Loading from '@/base/loading/index.js'
   2. const loading = Loading({ text: '正在加载。。。' })
   3. loading.close()
